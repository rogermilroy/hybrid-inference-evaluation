<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.2">
  <zoom_level>5</zoom_level>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>105</x>
      <y>5</y>
      <w>240</w>
      <h>195</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::PoseEstimation
--
#measurements: Measurements
#systems: Systems
#inputs: Inputs
-state: StatePtr
-filter: FilterPtr
-parameters: ParameterList
--
_+Instance()_
+init(): bool
+reset(): bool
+cleanup(): bool
+update(timestamp: ros::Time): void
+addSystem(system: System): SystemPtr
+addMeasurement(measurement: Measurement): MeasurementPtr
+addInput(input: Input): InputPtr
+getHeader(header: Header): void
+getState(state: Odometry): void
+getPose(pose: Pose): void
+getOrientation(orientation: Quaternion): void
--
Responsibilities
-- coordinates measurements and updates. 
-- Manages the State</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>420</x>
      <y>285</y>
      <w>255</w>
      <h>215</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::Filter::EKHI
--
#state: State
#F: State::SystemMatrix
#Ft: at::tensor
#yt: at::tensor
#Fs: at::tensor
#ys: at::tensor
#xs: at::tensor
#model: torch::jit::script::Module
#device: torch::Device
--
+getType(): std::string
+init(estimator: PoseEstimation): bool
+preparePredict(dt: double): bool
+predict(system SystemPtr, dt: double): bool
+predict(dt: double): bool
+doPredict(dt: double): bool
+prepareCorrect(): bool
+correct(measurement: MeasurementPtr): bool
+correct(): bool
+doCorrect(): bool
-systemMatrixToTensor(matrix: State::SystemMatrix): at::tensor
-tensorToVector(tensor: at::tensor, vec: State::Vector): void
-getStateAsEuler(vec: State::Vector): void
--
Responsibilities
-- Filtering inputs and producing estimates of state.</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>770</x>
      <y>315</y>
      <w>200</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::EKHI::Predictor::Predictor_
--
-filter_: EKHI
-model: SystemModel
--
#predict(dt: double): bool
--
Responsibilities
-- Estimates the system matrix F which is the Jacobian 
     of the System.
-- Updates the base filter yt with IMU measurements.
--
An internal class of EKHI</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>770</x>
      <y>430</y>
      <w>200</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::EKHI::Corrector
--
-filter_: EKHI
--
An internal class of EKHI</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>315</x>
      <y>535</y>
      <w>285</w>
      <h>85</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::MeasurementModel
--
#getExpectedValue(y_pred: MeasurementVector, state: State): void
#getStateJacobian(C: MeasurementMatrix, state: State): void
#getMeasurementNoise(R: NoiseVariance, state: State): void
#getCorrectedValue(y_in: MeasurementVector, y_out: at::tensor, state: State): void
+prepareUpdate(state: State, update: MeasurementUpdate): bool
--
Responsibilities
-- Represents the physical model of the measurement.
-- Converts raw values into xyz coordinates to fill the y.</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>0</x>
      <y>535</y>
      <w>285</w>
      <h>85</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::SystemModel
--
#getExpectedValue(y_pred: MeasurementVector, state: State): void
#getStateJacobian(C: MeasurementMatrix, state: State): void
#getSystemNoise(R: NoiseVariance, state: State): void
#getCorrectedValue(y_in: MeasurementVector, y_out: at::tensor, state: State): void
+prepareUpdate(state: State, update: MeasurementUpdate): bool
--
Responsibilities
-- Represents the physical system model.
-- Works out the Jacobian of the system to produce the F system matrix.</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>40</x>
      <y>650</y>
      <w>170</w>
      <h>85</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::
SystemModel::GenericQuaternionSystemModel

--
#imu_: ImuInput
#gyro_: Gyro
#accelerometer_: Accelerometer
--
+ See SystemModel
--
Responsibilities
-- Manages inertial measurements</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>590</x>
      <y>10</y>
      <w>245</w>
      <h>195</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::State
--
#vector_: Vector
#covariance_: Covariance
#system_status_: SystemStatus
#measurement_status_: SystemStatus
#substates_: SubStates
#base_: BaseState
#orientation_: OrientationState
#rate_: RateState
#position_: PositionState
#velocity_: VelocityState
#acceleration_: AccelerationState
#R_: RotationMatrix
--
+getVectorDimension(): IndexType
+getCovarianceDimension(): IndexType
+reset(): void
+updated(): void
+normalize(): void
+getVector(): Vector
+getCovariance(): Covariance
# update(vector_update: Vector): void
--
Responsibilities
-- Handle the state, what it is and any updates to it.</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>865</x>
      <y>85</y>
      <w>140</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::State::
OrientationPositionVelocityState
--
+ See State
--
+ See State
--
Responsibilities
-- See State</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>770</x>
      <y>225</y>
      <w>200</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::EKHI::Predictor
--
-filter_: EKHI
-F: SystemMatrix
--
#predict(dt: double): bool
--
An internal class of EKHI</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>770</x>
      <y>505</y>
      <w>200</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::EKHI::Corrector::Corrector_
--
-filter_: EKHI
-model: MeasurementModel
--
#correct(y: MeasurementVector, R: NoiseVariance): bool
--
Responsibilities
-- Updates the base filter (EKHI) yt with the y of this 
     measurement.
--
An internal class of EKHI</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>860</x>
      <y>275</y>
      <w>15</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>460</y>
      <w>15</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>445</y>
      <w>110</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>465</y>
      <w>110</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;10.0;100.0;110.0;200.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>370</y>
      <w>110</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>265</y>
      <w>110</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;180.0;100.0;180.0;100.0;10.0;200.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>390</y>
      <w>110</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>435</y>
      <w>110</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>645</x>
      <y>495</y>
      <w>135</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>250.0;100.0;10.0;100.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>640</x>
      <y>240</y>
      <w>140</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>615</x>
      <y>200</y>
      <w>15</w>
      <h>95</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>830</x>
      <y>105</y>
      <w>45</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>340</x>
      <y>135</y>
      <w>260</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>325</x>
      <y>195</y>
      <w>15</w>
      <h>350</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;680.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>220</x>
      <y>195</y>
      <w>15</w>
      <h>350</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;680.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>110</x>
      <y>615</y>
      <w>15</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>375</x>
      <y>655</y>
      <w>170</w>
      <h>85</h>
    </coordinates>
    <panel_attributes>hector_pose_estimation::
MeasurementModel::BaroModel

--
#qnh_: double
--
+ See MeasurementModel
+ getQnh(): double
+ getAlt(y_pred: MeasurementVector): double
--
Responsibilities
-- Represents the physical model of a Barometer.</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>455</x>
      <y>615</y>
      <w>15</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
</diagram>
